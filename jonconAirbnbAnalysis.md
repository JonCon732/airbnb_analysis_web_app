---
title: "AirBnB App"
Author: Jonathan Conrow
AuthorURL: https://www.jonathanconrow.com/
date: 8/25/2018
output: html_notebook
---



```{r}
setwd("/Users/jonathanconrow/Desktop/san_diego")
```

#Investigating the data sets
```{r}
#Import the proper library to look at the data
library(tidyverse)
library(jsonlite)
library(geojsonio)

#Import the different data sets from http://insideairbnb.com/get-the-data.html

calendar <- read_csv("calendar.csv")
listings <- read_csv("listings.csv")
neighborhoodS <- read_csv("neighbourhoods.csv")
reviews <- read_csv("reviews.csv")

geojson <- geojson_read("neighbourhoods.geojson", what = "sp")
#geojson <- readLines("neighbourhoods.geojson")
```

#Looking into the datasets
```{r}
head(calendar)
tail(calendar)
head(listings)
head(neighborhoodS)
head(reviews)
```
I like this dataset more than the Tom Slee dataset I was originally using, as it contains blocked outdates which I can use to get an estimated value of the worth of the property for the year. 

#Now it is important to see if this data set provides better insight than the Tom Slee dataset I was originally using
```{r}
summary(listings)
```
looking at the Summary of the data it appears to be lightly more evely disributed than that of the Tom Slee data. This is much more promising.

```{r}

#as the listings only gives us the number of available days in the year we need to make a variable populated with the number of days it was booked for the year
listings$booked <- 365-listings$availability_365

 #Now it is important to use the assumption that the blocked outdates for the year count as the rental location is booked and not just "blocked out" that way we can get a general idea of how much money the property is generating each year.
listings$yearlyRevenue <- listings$price * listings$booked
summary(listings)
```
#Distribution
Lookig at the the distrobution of the data

```{r}
#using the sqaure root at the breaks opposed to the min and max values give a better looking histogram
#but it is still long tail
n_breaks <- sqrt(nrow(listings))
breaksRevenue <- seq(from=min(listings$yearlyRevenue),
              to=max(listings$yearlyRevenue))
revenueHist <- hist(listings$yearlyRevenue, breaks=n_breaks, main = "Yearly Revenue", xlab = "Yearly Revenue")

breaksPrice <- seq(from=min(listings$price),
                   to=max(listings$price))
priceHist <- hist(listings$price, breaks=breaksPrice, main = "Price Per Night", xlab = "Nightly Price")

revenueHist
priceHist
```

#Looking at a scatter plot to see where the outliers are in the yearly revenue dataset inorder to make a more normalized distrobution

```{r}
plot(listings$yearlyRevenue, main = "Yearly Revenue", xlab = "Rental ID", ylab ="Revenue Generated by Rental (In $)")
```
#Outlier Cutoff, as the many outliers are causing the distribution to be long tail, I will use the general rule of thumb and cut out the outliers that are bigger than (Q3+1.5*IQR)

```{r}
outlier_cutoff <- quantile(listings$yearlyRevenue, 0.75)+1.5*IQR(listings$yearlyRevenue)
index_outlier_ROT <- which(listings$yearlyRevenue > outlier_cutoff)
yearly_revenue_ROT <- listings[-index_outlier_ROT,]

hist(yearly_revenue_ROT$yearlyRevenue, sqrt(nrow(yearly_revenue_ROT)), xlab = "Yearly Revenue")

```
#Still an issue
#As there is a frequency of rental properties that are listed for $0 a night, we are not interested in the rental locations that are available for free, it does not give us a good idea of what kind of evenue can be generated from renting out your home. This would also indicate a large number of unbooked properties for the year. As of now it is no interest to us.
```{r}
#Lets make a descision to exclude the unbooked properties.
index_outlier_greaterThan0 <- which(yearly_revenue_ROT$yearlyRevenue < 1)
data_greaterThan0 <- yearly_revenue_ROT[-index_outlier_greaterThan0,]
hist(data_greaterThan0$yearlyRevenue, sqrt(nrow(data_greaterThan0)), main = "Yearly Revenue Distibution", xlab = "Yearly Revenue")
```
This looks a lot better, although skewed we now have a better Idea of how the yearly revenue is distributed. As we can see there is a large number of the profits fall in the $20,000 range.

#Making a smaller Data Frame
I wish to make a smaller data frame that only contains the variables I am interested in
```{r}
library(ggplot2)
subBYneighbor <- subset(data_greaterThan0, select = c("yearlyRevenue", "neighbourhood"))
subBYroomType <- subset(data_greaterThan0, select = c("room_type", "yearlyRevenue"))

#ggplot(subBYneighbor, xName="Yearly Revenue", aes(yearlyRevenue, color= neighbourhood)) + geom_freqpoly(binwidth = 200)


ggplot(data_greaterThan0, xName="Yearly Revenue", groupName="Room Type",   aes(yearlyRevenue, fill= room_type)) + 
  geom_histogram(binwidth = 500) +
  xlab("Estimated Yearly Revenue in USD ($)") +
  ggtitle("Distibution of Estimated Yearly Revenue")+
  scale_x_continuous(labels = scales::dollar)+
  theme_bw()


```
As we can see in the histogram of Yearly Revenue subset by room_type, Entire home/apt listings bring in the most revenue

Looking deeper into this we find that entire home/apt rentals generate over $200,000,000 of estimated revenue

```{r}
    ggplot(data_greaterThan0, aes(room_type, yearlyRevenue, fill = room_type), groupName = "Rental Type")+
      ylab("Estimated Yearly Revenue in USD ($)") + xlab("Room Type")+
      ggtitle("Estimated Yearly Revenue by Rental Type")+
      geom_col(na.rm = TRUE)+
      theme_bw()+
      theme(axis.text.x = element_text(size = 15))+
      theme(axis.ticks = element_blank())+
      scale_y_continuous(labels = scales::dollar)
```


I think another interesting thing to see would be a bar chart of how each neighborhood performs in generating income.

```{r}
neighborhoodRevenue <- ggplot(data_greaterThan0, aes(neighbourhood, yearlyRevenue))+
  ylab("Estimated Yearly Revenue in USD ($)") + xlab("Neighborhood")+
  ggtitle("Estimated Yearly Revenue by Neighborhood")+
  geom_col()+
  theme_bw()+
  theme(axis.text.x = element_text(size = 5, angle = 90))+
  theme(axis.ticks = element_blank())+
  scale_y_continuous(labels = scales::dollar)
  
neighborhoodRevenue
sum(data_greaterThan0$yearlyRevenue)
```

###We see here that mission bay clearly stands out, bringing in $40 million of the total $279,956,896 generated by our yearly estimation on airBnB rentals in San Diego

It would be interesing to see what Type of revenue the entire home/apt rentals in Mission Bay account for
```{r}
missionBay <- subset(data_greaterThan0, neighbourhood == "Mission Bay")
entireHomeMissionBay <- subset(missionBay, room_type == "Entire home/apt") 

sum(entireHomeMissionBay$yearlyRevenue)
#using 
ggplot(entireHomeMissionBay, aes(price, yearlyRevenue))+
  ylab("Estimated Yearly Revenue in USD ($)") + xlab("Price Per Night USD ($)")+
  ggtitle("Smoothed Conditional Yearly Revenue of Entire Home/ Apt Rentals in Mission Bay")+
  geom_smooth()+
  theme_bw()+
  theme(axis.ticks = element_blank())+
  scale_y_continuous(labels = scales::dollar)+
  scale_x_continuous(labels = scales::dollar)

```

#Linear Regression Model
#The aim of using linear regression is to model a continuous variable Y (in this case it is #the estimated yearly profit) as a mathmatical function of X variables (the nightly cost and #the booked days). it can be represented with betas, beta1 being the intercept and beta2 #being its slope
###First, see it pictorially, then use the cor() function to see if there is a correlation
#Using a scatter plot we can see if there is some type of corelation between visually and #then the cor() function can be used to get a numeric value between -1 and +1. Where +1 would #be a strong correlation and -1 would be no correlation, in that X is a poor predictor of Y




```{r}
#A scatterplot can help to visualize the linear relationship(if on exists) between the estimated yearly revenue and the number of blocked out days assuming the blocked out days are bookings
scatter.smooth(x=data_greaterThan0$booked + data_greaterThan0$price, y=data_greaterThan0$yearlyRevenue, main="Estimated Yearly Revenue ~ Number of blocked out days")
correlation <- cor(data_greaterThan0$booked, data_greaterThan0$yearlyRevenue )
print(paste("The calculated correlations between blocked out days and yearly revenue:",correlation))
```
as we can see that there is somewhat of a correlation between the number of nights that are blocked out on the calander and the estimated yearly revenue. The numeric value of or the correlation function returned a correlation of 0.497. Which would suggest that X variables (assumed booked nights and the price per night) is not a poor predictor of Y(estimated yearly revenue).

#Building a linear model
```{r}
#Build linear regression model of the full data
#the linear model esatblises the relationshi between the predictor and response in the form of a mathmatical formula for Estimated Yearly Revenue as a function of Assumed Booked Nights
linearMod <- lm(yearlyRevenue ~ booked + price, data = data_greaterThan0)

#printing the model returns the beta coeffiecents
print(linearMod)

##lets see if the linear model is statisically significant
summary(linearMod)


```

Looking at the linear model summary, it can be seen the the p-values fall way below the ideal 0.05 threshold and reveal their significance

```{r}
AIC(linearMod)
BIC(linearMod)
```
#Predicting Linear Model
##Create the training and test datasets from original data
```{r}
#create training and test data sets
#set see to reproduce results of random sampling
set.seed(100)

#the row indicies for the training data
trainingRowIndex <- sample(1:nrow(data_greaterThan0), 0.8*nrow(data_greaterThan0))

trainingData <- data_greaterThan0[trainingRowIndex,] #model training data
testData <- data_greaterThan0[-trainingRowIndex,] #test data
```
##Now that the training and test data sets have been indexed, we must develope the model on the training data and use it to predict the estimated yearly revenue
```{r}
#build the model on training data
lmMod <- lm(yearlyRevenue ~ booked + price, data = trainingData) #build the model
revPredict <- predict(lmMod, testData) #predict the estimated yearly revenue

#review the diagnostic measures
summary(lmMod)
AIC(lmMod)
```
the model p values are still way below the significance level and the R squared values are slightly higher than that of our original model

##Calculate predictiion accuracy and error rates
```{r}
#make a dataframe of the actual values and predicted values from our model
actual_preds <-  data.frame(cbind(actuals=testData$yearlyRevenue, predicted=revPredict))
correlation_accuracy <- cor(actual_preds) #76.0%
#head(actual_preds)
#correlation_accuracy
```
We see that our prediction model is performs with 76.0% accuacy. It is not the best but is not the worst.

##Min Max Accurqcy and Mean Absolute Percentage error:
```{r}
min_max_accuracy <- mean(apply(actual_preds, 1, min)/ apply(actual_preds, 1, max))
#min_max_accuracy 17.90%
mape <- mean(abs((actual_preds$predicted-actual_preds$actuals))/actual_preds$actuals)
#mape 115.76%
#min_max_accuracy
#mape
```



#Using Shiny and Leaflet to make a web App to show this data.

```{r}
#Input our libraries to create the app
library(shinydashboard)
library(shiny)
library(leaflet)
library(RColorBrewer)

```

#Need a vector of Neighborhoods
```{r}
neighborhoods <- as.character(geojson$neighbourhood)
```



```{r}
#Make the Ui portion of the shiny app
ui <- dashboardPage(
  skin = "black",
  dashboardHeader(title = "San Diego AirBnB, Where to Invest",
                  titleWidth = 450),
  dashboardSidebar(
    collapsed = TRUE,
    sidebarMenu(
      menuItem("Map", tabName = "mapss", icon = icon("map-pin")),
      menuItem("Stats", tabName = "stats", icon = icon("signal")),
      menuItem("Source Data", tabName = "sourceData", icon = icon("download")),
      menuItem("Code", tabName = "sourceCode", icon = icon("code"))
    )
  ),
  dashboardBody(
    tabItems(
      #Mapss tab Item
      tabItem(tabName = "mapss",
              fluidPage(
                #leflet map output in this dashboard
                box(leafletOutput("myMap")),
                
                #select inputbox for map
                box(
                  title = "Select Your Location and Rental Type",
                  solidHeader = TRUE,
                  collapsible = TRUE,
                  background = "black",
                  footer = TRUE,
                  checkboxGroupInput("selectRoom","Select a Rental Type",
                                     c("Entire Home/Apt" = "Entire home/apt",
                                       "Private Room" = "Private room",
                                       "Shared Room" = "Shared room")),
                  p(class = "text-muted",
                    br(),
                    "By clicking on a marker you can view the estimated yearly income of the property, derived from the yearly blocked out days and the cost per night "),
                  selectInput("selectNeighborhood", "View Neighborhoods", 
                              c(All = "all", neighborhoods))
                ),
                
                
                #Add a action button for clearing the tiles
                actionButton("clear", "Clear Map", icon = icon("refresh"))
              ),
              #Infoboxes providing data for the app
              fluidRow(box(
                column(width = 1,
                       fluidRow(
                         infoBox("Rental Locations", 9486, icon = icon("hashtag"))
                         ),
                       fluidRow(
                         infoBox("Mean Yearly Profit", round(mean(data_greaterThan0$yearlyRevenue),2),icon = icon("usd"))
                       )
                )
              )
              ),
              p(class = "text-muted",
                "This web application and all of its parts have no formal connection to any of the listed sites or AirBnB itself. It is strictly for educational purposes and a interest in analysis of the sharing econonmy data.")
      ),
      
      #Second Tab Content
      tabItem(tabName = "stats",
              fluidRow(
                column(
                  width = 12,
                  #show a plot of distribution
                  h3("Distribution of Estimated Yearly Revenue"),
                  plotOutput("distPlot"),
                  p(class = "text-muted",
                    "The above histogram was derived for trimming down the original data set and excluding any propertys that were listed for $0, as they are not generating revenue. The Estimated revenue value was derived from the number of blocked calender dates (assuming these are bookings and not just blocked days) and multiplying them by the Price per night. This method may not be very accurate but may provide insight into the type of information that may be translatable to other industries. "),
                  #show a barchart of the rental types and how much revenue they are generating,
                  br(),
                  h3("Bar Chart of Estimated Yearly Revenue per Rental Type"),
                  plotOutput("barChart"),
                  p(class = "text-muted",
                    "To further investigate the distribution, I thought it would be interesting to see what the estimated revenue would be depending on the rental type, as in the distribution it is clear that a entire home/ apartment rental is the most predominant rental type. As we can see from this chart, all of the home/apt rental accounts for over $200 million generated."),
                  br(),
                  h3("Bar Chart of Estimated Yearly Revenue by Neighborhood"),
                  plotOutput("barChart2"),
                  p(class = "text-muted",
                    "Looking Further into what locations generate the most revenue, we can see that Mission Bay, California generates an estimated $40 million in AirBnB rental revenue "),
                  br(),
                  h3("Smoothed Conditional of The Estimated Yearly Revenue as a Function of Nightly Cost for a Entire Home/Apt in Mission Bay"),
                  plotOutput("smoothedCond"),
                  p(class = "text-muted",
                    "We can now see a trend clearly in the Mission Bay subset of data that only contains Entire Home/ Apartment Rental listings. It appears as the nightly rate goes up so does the estimated yearly revenue. This could potentially indicate that there is a steady number of bookings in Mission Bay and/or there is a high demand for rentals in this location and not a large supply. This may interest housing developers looking to build homes strictly to rent for AirBnB Purposes.")
                )
              )
      ),
      
      #Third Tab Content
      tabItem(tabName = "sourceData",
              fluidPage(
                h2("Download The Source Data"),
                h4("Source data can be downloaded from the link below"),
                htmlOutput("hyperlink")
              )
      ),
      
      tabItem(tabName = "sourceCode",
              fluidPage(
                h2("Download The Source Code"),
                h4("The code for this entire app and project can be down loaded from the link below"),
                htmlOutput("codeHyperlink")
              )
      )
    )
  )
)

#make the server portion of the app
server <- function(input, output) {
  
  
  filterData <- eventReactive(input$selectRoom, {
    subset(data_greaterThan0, room_type == input$selectRoom)
  }, ignoreNULL = TRUE)
  
  #make a reactive value that could be called for a event reactive based on the geojson neighborhood polygons
  neighReactive <- reactive(geojson)
  
  #event reactive to be called for graphing the neighborhoods
  filterNeighborhood <- eventReactive(input$selectNeighborhood, {
    if(input$selectNeighborhood == "all"){
      neighReactive()
    }else{subset(geojson, neighbourhood == input$selectNeighborhood)
    }
  })
  #filterNeighborhood <- eventReactive(input$selectNeighborhood, {
  # subset(geojson, neighbourhood == input$selectNeighborhood)
  #}, ignoreNULL = TRUE)
  
  
  #Use leaflet here for the base map
  output$myMap <- renderLeaflet({
    leaflet(data_greaterThan0) %>%
      addProviderTiles(providers$Stamen.Toner) %>%
      fitBounds(~min(longitude), ~min(latitude), ~max(longitude), ~max(latitude))
    
  })
  
  #Makeing incramental changes to the map using proxy layers
  #Input for the room types
  observeEvent(input$selectRoom, {
    leafletProxy("myMap", data = filterData()) %>%
      clearMarkerClusters() %>%
      addMarkers(~longitude, ~latitude,
                 popup = ~paste0("Yearly Income $",yearlyRevenue),
                 #markerOptions(clickable = TRUE, riseOnHover = TRUE),
                 clusterOptions = markerClusterOptions(showCoverageOnHover = FALSE,
                                                       spiderfyOnMaxZoom = TRUE)) %>%
      fitBounds(~min(longitude), ~min(latitude), ~max(longitude), ~max(latitude))
  })
  
  #Input for the geojson
  observeEvent(input$selectNeighborhood, {
    leafletProxy("myMap", data = filterNeighborhood()) %>%
      clearShapes() %>%
      addPolygons(stroke = FALSE,
                  weight = 2,
                  opacity = 1,
                  color = "pink",
                  dashArray = "1",
                  smoothFactor = 0.3, 
                  fillOpacity = 0.4, 
                  fillColor = "blue", 
                  label = ~paste0(neighbourhood),
                  highlight = highlightOptions(
                    stroke = TRUE,
                    weight = 3,
                    color = "pink",
                    fillOpacity = 0.7,
                    bringToFront = TRUE
                  ))
  })
  
  #Create a button that clears all markers form the mapp
  observeEvent(input$clear, {
    leafletProxy("myMap", data = filterData()) %>%
      clearMarkerClusters()
  })
  
  output$hyperlink <- renderUI({
    tags$a(href="http://insideairbnb.com/get-the-data.html", "Click here!")
  })
  
  #Output a ggplot of the Histogram of estimated yearly revenue
  output$distPlot <- renderPlot({
    ggplot(data_greaterThan0, xName="Yearly Revenue", groupName="Room Type",   aes(yearlyRevenue, fill= room_type)) +
      geom_histogram(binwidth = 500) +
      ggtitle("Distibution of Estimated Yearly Revenue")+
      xlab("Estimated Yearly Revenue in USD ($)") +
      theme_bw()+
      scale_x_continuous(labels = scales::dollar)
  })
  
  output$barChart2 <- renderPlot({
    ggplot(data_greaterThan0, aes(neighbourhood, yearlyRevenue))+
      ylab("Estimated Yearly Revenue in USD ($)") + xlab("Neighborhood")+
      ggtitle("Estimated Yearly Revenue by Neighborhood")+
      geom_col(na.rm = TRUE)+
      theme_bw()+
      theme(axis.text.x = element_text(size = 9, angle = 90))+
      theme(axis.ticks = element_blank())+
      scale_y_continuous(labels = scales::dollar)
  })
  
    output$barChart <- renderPlot({
    ggplot(data_greaterThan0, aes(room_type, yearlyRevenue, fill = room_type), groupName = "Rental Type")+
      ylab("Estimated Yearly Revenue in USD ($)") + xlab("Room Type")+
      ggtitle("Estimated Yearly Revenue by Rental Type")+
      geom_col(na.rm = TRUE)+
      theme_bw()+
      theme(axis.text.x = element_text(size = 15))+
      theme(axis.ticks = element_blank())+
      scale_y_continuous(labels = scales::dollar)
  })
    
    output$smoothedCond <- renderPlot({
      ggplot(entireHomeMissionBay, aes(price, yearlyRevenue))+
        ylab("Estimated Yearly Revenue in USD ($)") + xlab("Price Per Night USD ($)")+
        ggtitle("Smoothed Conditional Yearly Revenue of Entire Home/ Apt Rentals in Mission Bay")+
        geom_smooth()+
        theme_bw()+
        theme(axis.ticks = element_blank())+
        scale_y_continuous(labels = scales::dollar)+
        scale_x_continuous(labels = scales::dollar)
    })
#  output$histTable <- renderTable({
#    summary(data_greaterThan0)
#  })
  
}


shinyApp(ui, server)
```





#Next I would like to see what the profits are by location
To do this, I will subset the data by the neighborhoods the properties are located in



Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Cmd+Option+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Cmd+Shift+K* to preview the HTML file). 

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.

